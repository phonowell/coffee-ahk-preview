; Generated by Coffee-AHK/0.0.39

#HotkeyInterval, 1000
#KeyHistory, 0
#MaxHotkeysPerInterval, 200
#MaxThreads, 20
#NoEnv
#Persistent
#SingleInstance, Force
#UseHook, On

CoordMode, Mouse, Client
CoordMode, Pixel, Client
CoordMode, ToolTip, Client
SendMode, Event
SetBatchLines, 10ms
SetKeyDelay, 0, 50
SetMouseDelay, 0, 50
StringCaseSense, On
;
; Neutron.ahk v1.0.0
; Copyright (c) 2020 Philip Taylor (known also as GeekDude, G33kDude)
; https://github.com/G33kDude/Neutron.ahk
;
; MIT License
;
; Permission is hereby granted, free of charge, to any person obtaining a copy
; of this software and associated documentation files (the "Software"), to deal
; in the Software without restriction, including without limitation the rights
; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
; copies of the Software, and to permit persons to whom the Software is
; furnished to do so, subject to the following conditions:
;
; The above copyright notice and this permission notice shall be included in all
; copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
; SOFTWARE.
;

class NeutronWindow
{
	static TEMPLATE := "
( ; html
<!DOCTYPE html><html>
<head>

<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<style>
	html, body {
		width: 100%; height: 100%;
		margin: 0; padding: 0;
		font-family: sans-serif;
	}

	body {
		display: flex;
		flex-direction: column;
	}

	header {
		width: 100%;
		display: flex;
		background: silver;
		font-family: Segoe UI;
		font-size: 9pt;
	}

	.title-bar {
		padding: 0.35em 0.5em;
		flex-grow: 1;
	}

	.title-btn {
		padding: 0.35em 1.0em;
		cursor: pointer;
		vertical-align: bottom;
		font-family: Webdings;
		font-size: 11pt;
	}

	.title-btn:hover {
		background: rgba(0, 0, 0, .2);
	}

	.title-btn-close:hover {
		background: #dc3545;
	}

	.main {
		flex-grow: 1;
		padding: 0.5em;
		overflow: auto;
	}
</style>
<style>{}</style>

</head>
<body>

<header>
	<span class='title-bar' onmousedown='neutron.DragTitleBar()'>{}</span>
	<span class='title-btn' onclick='neutron.Minimize()'>0</span>
	<span class='title-btn' onclick='neutron.Maximize()'>1</span>
	<span class='title-btn title-btn-close' onclick='neutron.Close()'>r</span>
</header>

<div class='main'>{}</div>

<script>{}</script>

</body>
</html>
)"
	
	; --- Constants ---
	
	static VERSION := "1.0.0"
	
	; Windows Messages
	, WM_DESTROY := 0x02
	, WM_SIZE := 0x05
	, WM_NCCALCSIZE := 0x83
	, WM_NCHITTEST := 0x84
	, WM_NCLBUTTONDOWN := 0xA1
	, WM_KEYDOWN := 0x100
	, WM_MOUSEMOVE := 0x200
	, WM_LBUTTONDOWN := 0x201
	
	; Non-client hit test values (WM_NCHITTEST)
	, HT_VALUES := [[13, 12, 14], [10, 1, 11], [16, 15, 17]]
	
	; Registry keys
	, KEY_FBE := "HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\MAIN"
	. "\FeatureControl\FEATURE_BROWSER_EMULATION"
	
	; Undoucmented Accent API constants
	; https://withinrafael.com/2018/02/02/adding-acrylic-blur-to-your-windows-10-apps-redstone-4-desktop-apps/
	, ACCENT_ENABLE_BLURBEHIND := 3
	, WCA_ACCENT_POLICY := 19
	
	; Other constants
	, EXE_NAME := A_IsCompiled ? A_ScriptName : StrSplit(A_AhkPath, "\").Pop()
	
	
	; --- Instance Variables ---
	
	; Maximum pixel inset for sizing handles to appear
	border_size := 6
	
	; The window size
	w := 800
	h := 600
	
	
	; --- Properties ---
	
	; Get the JS DOM object
	doc[]
	{
		get
		{
			return this.wb.Document
		}
	}
	
	; Get the JS Window object
	wnd[]
	{
		get
		{
			return this.wb.Document.parentWindow
		}
	}
	
	
	; --- Construction, Destruction, Meta-Functions ---
	
	__New(html:="", css:="", js:="", title:="Neutron")
	{
		static wb
		this.LISTENERS := [this.WM_DESTROY, this.WM_SIZE, this.WM_NCCALCSIZE
		, this.WM_KEYDOWN, this.WM_LBUTTONDOWN]
		
		; Create necessary circular references
		this.bound := {}
		this.bound._OnMessage := this._OnMessage.Bind(this)
		
		; Bind message handlers
		for i, message in this.LISTENERS
			OnMessage(message, this.bound._OnMessage)
		
		; Create and save the GUI
		; TODO: Restore previous default GUI
		Gui, New, +hWndhWnd +Resize -DPIScale
		this.hWnd := hWnd
		
		; Enable shadow
		VarSetCapacity(margins, 16, 0)
		NumPut(1, &margins, 0, "Int")
		DllCall("Dwmapi\DwmExtendFrameIntoClientArea"
		, "UPtr", hWnd      ; HWND hWnd
		, "UPtr", &margins) ; MARGINS *pMarInset
		
		; When manually resizing a window, the contents of the window often "lag
		; behind" the new window boundaries. Until they catch up, Windows will
		; render the border and default window color to fill that area. On most
		; windows this will cause no issue, but for borderless windows this can
		; cause rendering artifacts such as thin borders or unwanted colors to
		; appear in that area until the rest of the window catches up.
		;
		; When creating a dark-themed application, these artifacts can cause
		; jarringly visible bright areas. This can be mitigated some by changing
		; the window settings to cause dark/black artifacts, but it's not a
		; generalizable approach, so if I were to do that here it could cause
		; issues with light-themed apps.
		;
		; Some borderless window libraries, such as rossy's C implementation
		; (https://github.com/rossy/borderless-window) hide these artifacts by
		; playing with the window transparency settings which make them go away
		; but also makes it impossible to show certain colors (in rossy's case,
		; Fuchsia/FF00FF).
		;
		; Luckly, there's an undocumented Windows API function in user32.dll
		; called SetWindowCompositionAttribute, which allows you to change the
		; window accenting policies. This tells the DWM compositor how to fill
		; in areas that aren't covered by controls. By enabling the "blurbehind"
		; accent policy, Windows will render a blurred version of the screen
		; contents behind your window in that area, which will not be visually
		; jarring regardless of the colors of your application or those behind
		; it.
		;
		; Because this API is undocumented (and unavailable in Windows versions
		; below 10) it's not a one-size-fits-all solution, and could break with
		; future system updates. Hopefully a better soultion for the problem
		; this hack addresses can be found for future releases of this library.
		;
		; https://withinrafael.com/2018/02/02/adding-acrylic-blur-to-your-windows-10-apps-redstone-4-desktop-apps/
		; https://github.com/melak47/BorderlessWindow/issues/13#issuecomment-309154142
		; http://undoc.airesoft.co.uk/user32.dll/SetWindowCompositionAttribute.php
		; https://gist.github.com/riverar/fd6525579d6bbafc6e48
		; https://vhanla.codigobit.info/2015/07/enable-windows-10-aero-glass-aka-blur.html
		
		Gui, Color, 0, 0
		VarSetCapacity(wcad, A_PtrSize+A_PtrSize+4, 0)
		NumPut(this.WCA_ACCENT_POLICY, &wcad, 0, "Int")
		VarSetCapacity(accent, 16, 0)
		NumPut(this.ACCENT_ENABLE_BLURBEHIND, &accent, 0, "Int")
		NumPut(&accent, &wcad, A_PtrSize, "Ptr")
		NumPut(16, &wcad, A_PtrSize+A_PtrSize, "Int")
		DllCall("SetWindowCompositionAttribute", "UPtr", hWnd, "UPtr", &wcad)
		
		; Creating an ActiveX control with a valid URL instantiates a
		; WebBrowser, saving its object to the associated variable. The "about"
		; URL scheme allows us to start the control on either a blank page, or a
		; page with some HTML content pre-loaded by passing HTML after the
		; colon: "about:<!DOCTYPE html><body>...</body>"
		
		; Read more about the WebBrowser control here:
		; http://msdn.microsoft.com/en-us/library/aa752085
		
		; For backwards compatibility reasons, the WebBrowser control defaults
		; to IE7 emulation mode. The standard method of mitigating this is to
		; include a compatibility meta tag in the HTML, but this requires
		; tampering to the HTML and does not solve all compatibility issues.
		; By tweaking the registry before and after creation of the control we
		; can opt-out of the browser emulation feature altogether with minimal
		; impact on the rest of the system.
		
		; Read more about browser compatibility modes here:
		; https://docs.microsoft.com/en-us/archive/blogs/patricka/controlling-webbrowser-control-compatibility
		
		RegRead, fbe, % this.KEY_FBE, % this.EXE_NAME
		RegWrite, REG_DWORD, % this.KEY_FBE, % this.EXE_NAME, 0
		Gui, Add, ActiveX, vwb hWndhWB x0 y0 w800 h600, about:blank
		if (fbe = "")
			RegDelete, % this.KEY_FBE, % this.EXE_NAME
		else
			RegWrite, REG_DWORD, % this.KEY_FBE, % this.EXE_NAME, % fbe
		
		; Save the WebBrowser control to reference later
		this.wb := wb
		this.hWB := hWB
		
		; Connect the web browser's event stream to a new event handler object
		ComObjConnect(this.wb, new this.WBEvents(this))
		
		; Compute the HTML template if necessary
		if !(html ~= "i)^<!DOCTYPE")
			html := Format(this.TEMPLATE, css, title, html, js)
		
		; Write the given content to the page
		this.doc.write(html)
		this.doc.close()
		
		; Inject the AHK objects into the JS scope
		this.wnd.neutron := this
		this.wnd.ahk := new this.Dispatch(this)
		
		; Wait for the page to finish loading
		while wb.readyState < 4
			Sleep, 50
		
		; Subclass the rendered Internet Explorer_Server control to intercept
		; its events, including WM_NCHITTEST and WM_NCLBUTTONDOWN.
		; Read more here: https://forum.juce.com/t/_/27937
		; And in the AutoHotkey documentation for RegisterCallback (Example 2)
		
		dhw := A_DetectHiddenWindows
		DetectHiddenWindows, On
		ControlGet, hWnd, hWnd,, Internet Explorer_Server1, % "ahk_id" this.hWnd
		this.hIES := hWnd
		DetectHiddenWindows, %dhw%
		
		this.pWndProc := RegisterCallback(this._WindowProc, "", 4, &this)
		this.pWndProcOld := DllCall("SetWindowLong" (A_PtrSize == 8 ? "Ptr" : "")
		, "Ptr", hWnd          ; HWND     hWnd
		, "Int", -4            ; int      nIndex (GWLP_WNDPROC)
		, "Ptr", this.pWndProc ; LONG_PTR dwNewLong
		, "Ptr") ; LONG_PTR
		
		; Stop the WebBrowser control from consuming file drag and drop events
		this.wb.RegisterAsDropTarget := False
		DllCall("ole32\RevokeDragDrop", "UPtr", this.hIES)
	}
	
	; Show an alert for debugging purposes when the class gets garbage collected
	; __Delete()
	; {
	; 	MsgBox, __Delete
	; }
	
	
	; --- Event Handlers ---
	
	_OnMessage(wParam, lParam, Msg, hWnd)
	{
		if (hWnd == this.hWnd)
		{
			; Handle messages for the main window
			
			if (Msg == this.WM_NCCALCSIZE)
			{
				; Size the client area to fill the entire window.
				; See this project for more information:
				; https://github.com/rossy/borderless-window
				
				; Fill client area when not maximized
				if !DllCall("IsZoomed", "UPtr", hWnd)
					return 0
				; else crop borders to prevent screen overhang
				
				; Query for the window's border size
				VarSetCapacity(windowinfo, 60, 0)
				NumPut(60, windowinfo, 0, "UInt")
				DllCall("GetWindowInfo", "UPtr", hWnd, "UPtr", &windowinfo)
				cxWindowBorders := NumGet(windowinfo, 48, "Int")
				cyWindowBorders := NumGet(windowinfo, 52, "Int")
				
				; Inset the client rect by the border size
				NumPut(NumGet(lParam+0, "Int") + cxWindowBorders, lParam+0, "Int")
				NumPut(NumGet(lParam+4, "Int") + cyWindowBorders, lParam+4, "Int")
				NumPut(NumGet(lParam+8, "Int") - cxWindowBorders, lParam+8, "Int")
				NumPut(NumGet(lParam+12, "Int") - cyWindowBorders, lParam+12, "Int")
				
				return 0
			}
			else if (Msg == this.WM_SIZE)
			{
				; Extract size from LOWORD and HIWORD (preserving sign)
				this.w := w := lParam<<48>>48
				this.h := h := lParam<<32>>48
				
				DllCall("MoveWindow", "UPtr", this.hWB, "Int", 0, "Int", 0, "Int", w, "Int", h, "UInt", 0)
				
				return 0
			}
			else if (Msg == this.WM_DESTROY)
			{
				; Clean up all our circular references so that the object may be
				; garbage collected.
				
				for i, message in this.LISTENERS
					OnMessage(message, this.bound._OnMessage, 0)
				this.bound := []
			}
		}
		else if (hWnd == this.hIES)
		{
			; Handle messages for the rendered Internet Explorer_Server
			
			if (Msg == this.WM_KEYDOWN)
			{
				; Accelerator handling code from AutoHotkey Installer
				
				if (Chr(wParam) ~= "[A-Z]" || wParam = 0x74) ; Disable Ctrl+O/L/F/N and F5.
					return
				Gui +OwnDialogs ; For threadless callbacks which interrupt this.
				pipa := ComObjQuery(this.wb, "{00000117-0000-0000-C000-000000000046}")
				VarSetCapacity(kMsg, 48), NumPut(A_GuiY, NumPut(A_GuiX
				, NumPut(A_EventInfo, NumPut(lParam, NumPut(wParam
				, NumPut(Msg, NumPut(hWnd, kMsg)))), "uint"), "int"), "int")
				Loop 2
					r := DllCall(NumGet(NumGet(1*pipa)+5*A_PtrSize), "ptr", pipa, "ptr", &kMsg)
				; Loop to work around an odd tabbing issue (it's as if there
				; is a non-existent element at the end of the tab order).
				until wParam != 9 || this.wb.document.activeElement != ""
				ObjRelease(pipa)
				if r = 0 ; S_OK: the message was translated to an accelerator.
					return 0
				return
			}
		}
	}
	
	_WindowProc(Msg, wParam, lParam)
	{
		Critical
		hWnd := this
		this := Object(A_EventInfo)
		
		if (Msg == this.WM_NCHITTEST)
		{
			; Check to see if the cursor is near the window border, which
			; should be treated as the "non-client" drag-to-resize area.
			; https://autohotkey.com/board/topic/23969-/#entry155480
			
			; Extract coordinates from LOWORD and HIWORD (preserving sign)
			x := lParam<<48>>48, y := lParam<<32>>48
			
			; Get the window position for comparison
			WinGetPos, wX, wY, wW, wH, % "ahk_id" this.hWnd
			
			; Calculate positions in the lookup tables
			row := (x < wX + this.BORDER_SIZE) ? 1 : (x >= wX + wW - this.BORDER_SIZE) ? 3 : 2
			col := (y < wY + this.BORDER_SIZE) ? 1 : (y >= wY + wH - this.BORDER_SIZE) ? 3 : 2
			
			return this.HT_VALUES[col, row]
		}
		else if (Msg == this.WM_NCLBUTTONDOWN)
		{
			; Hoist nonclient clicks to main window
			return DllCall("SendMessage", "Ptr", this.hWnd, "UInt", Msg, "UPtr", wParam, "Ptr", lParam, "Ptr")
		}
		
		; Otherwise (since above didn't return), pass all unhandled events to the original WindowProc.
		return DllCall("CallWindowProc"
		, "Ptr", this.pWndProcOld ; WNDPROC lpPrevWndFunc
		, "Ptr", hWnd             ; HWND    hWnd
		, "UInt", Msg             ; UINT    Msg
		, "UPtr", wParam          ; WPARAM  wParam
		, "Ptr", lParam           ; LPARAM  lParam
		, "Ptr") ; LRESULT
	}
	
	
	; --- Instance Methods ---
	
	; Triggers window dragging. Call this on mouse click down. Best used as your
	; title bar's onmousedown attribute.
	DragTitleBar()
	{
		PostMessage, this.WM_NCLBUTTONDOWN, 2, 0,, % "ahk_id" this.hWnd
	}
	
	; Minimizes the Neutron window. Best used in your title bar's minimize
	; button's onclick attribute.
	Minimize()
	{
		Gui, % this.hWnd ":Minimize"
	}
	
	; Maximize the Neutron window. Best used in your title bar's maximize
	; button's onclick attribute.
	Maximize()
	{
		if DllCall("IsZoomed", "UPtr", this.hWnd)
			Gui, % this.hWnd ":Restore"
		else
			Gui, % this.hWnd ":Maximize"
	}
	
	; Closes the Neutron window. Best used in your title bar's close
	; button's onclick attribute.
	Close()
	{
		WinClose, % "ahk_id" this.hWnd
	}
	
	; Hides the Nuetron window.
	Hide()
	{
		Gui, % this.hWnd ":Hide"
	}
	
	; Destroys the Neutron window. Do this when you would no longer want to
	; re-show the window, as it will free the memory taken up by the GUI and
	; ActiveX control. This method is best used either as your title bar's close
	; button's onclick attribute, or in a custom window close routine.
	Destroy()
	{
		Gui, % this.hWnd ":Destroy"
	}
	
	; Shows a hidden Neutron window.
	Show(options:="")
	{
		w := RegExMatch(options, "w\s*\K\d+", match) ? match : this.w
		h := RegExMatch(options, "h\s*\K\d+", match) ? match : this.h
		
		; AutoHotkey sizes the window incorrectly, trying to account for borders
		; that aren't actually there. Call the function AHK uses to offset and
		; apply the change in reverse to get the actual wanted size.
		VarSetCapacity(rect, 16, 0)
		DllCall("AdjustWindowRectEx"
		, "Ptr", &rect ;  LPRECT lpRect
		, "UInt", 0x80CE0000 ;  DWORD  dwStyle
		, "UInt", 0 ;  BOOL   bMenu
		, "UInt", 0 ;  DWORD  dwExStyle
		, "UInt") ; BOOL
		w += NumGet(&rect, 0, "Int")-NumGet(&rect, 8, "Int")
		h += NumGet(&rect, 4, "Int")-NumGet(&rect, 12, "Int")
		
		Gui, % this.hWnd ":Show", %options% w%w% h%h%
	}
	
	; Loads an HTML file by name (not path). When running the script uncompiled,
	; looks for the file in the local directory. When running the script
	; compiled, looks for the file in the EXE's RCDATA. Files included in your
	; compiled EXE by FileInstall are stored in RCDATA whether they get
	; extracted or not. An easy way to get your Neutron resources into a
	; compiled script, then, is to put FileInstall commands for them right below
	; the return at the bottom of your AutoExecute section.
	;
	; Parameters:
	;   fileName - The name of the HTML file to load into the Neutron window.
	;              Make sure to give just the file name, not the full path.
	;
	; Returns: nothing
	;
	; Example:
	;
	; ; AutoExecute Section
	; neutron := new NeutronWindow()
	; neutron.Load("index.html")
	; neutron.Show()
	; return
	; FileInstall, index.html, index.html
	; FileInstall, index.css, index.css
	;
	Load(fileName)
	{
		; Complete the path based on compiled state
		if A_IsCompiled
			url := "res://" this.wnd.encodeURIComponent(A_ScriptFullPath) "/10/" fileName
		else
			url := A_WorkingDir "/" fileName
		
		; Navigate to the calculated file URL
		this.wb.Navigate(url)
		
		; Wait for the page to finish loading
		while this.wb.readyState < 3
			Sleep, 50
		
		; Inject the AHK objects into the JS scope
		this.wnd.neutron := this
		this.wnd.ahk := new this.Dispatch(this)
		
		; Wait for the page to finish loading
		while this.wb.readyState < 4
			Sleep, 50
	}
	
	; Shorthand method for document.querySelector
	qs(selector)
	{
		return this.doc.querySelector(selector)
	}
	
	; Shorthand method for document.querySelectorAll
	qsa(selector)
	{
		return this.doc.querySelectorAll(selector)
	}
	
	; Passthrough method for the Gui command, targeted at the Neutron Window
	; instance
	Gui(subCommand, value1:="", value2:="", value3:="")
	{
		Gui, % this.hWnd ":" subCommand, %value1%, %value2%, %value3%
	}
	
	
	; --- Static Methods ---
	
	; Given an HTML Collection (or other JavaScript array), return an enumerator
	; that will iterate over its items.
	;
	; Parameters:
	;     htmlCollection - The JavaScript array to be iterated over
	;
	; Returns: An Enumerable object
	;
	; Example:
	;
	; neutron := new NeutronWindow("<body><p>A</p><p>B</p><p>C</p></body>")
	; neutron.Show()
	; for i, element in neutron.Each(neutron.body.children)
	;     MsgBox, % i ": " element.innerText
	;
	Each(htmlCollection)
	{
		return new this.Enumerable(htmlCollection)
	}
	
	; Given an HTML Form Element, construct a FormData object
	;
	; Parameters:
	;   formElement - The HTML Form Element
	;   useIdAsName - When a field's name is blank, use it's ID instead
	;
	; Returns: A FormData object
	;
	; Example:
	;
	; neutron := new NeutronWindow("<form>"
	; . "<input type='text' name='field1' value='One'>"
	; . "<input type='text' name='field2' value='Two'>"
	; . "<input type='text' name='field3' value='Three'>"
	; . "</form>")
	; neutron.Show()
	; formElement := neutron.doc.querySelector("form") ; Grab 1st form on page
	; formData := neutron.GetFormData(formElement) ; Get form data
	; MsgBox, % formData.field2 ; Pull a single field
	; for name, element in formData ; Iterate all fields
	;     MsgBox, %name%: %element%
	;
	GetFormData(formElement, useIdAsName:=True)
	{
		formData := new this.FormData()
		
		for i, field in this.Each(formElement.elements)
		{
			; Discover the field's name
			name := ""
			try ; fieldset elements error when reading the name field
				name := field.name
			if (name == "" && useIdAsName)
				name := field.id
			
			; Filter against fields which should be omitted
			if (name == "" || field.disabled
				|| field.type ~= "^file|reset|submit|button$")
				continue
			
			; Handle select-multiple variants
			if (field.type == "select-multiple")
			{
				for j, option in this.Each(field.options)
					if (option.selected)
						formData.add(name, option.value)
				continue
			}
			
			; Filter against unchecked checkboxes and radios
			if (field.type ~= "^checkbox|radio$" && !field.checked)
				continue
			
			; Return the field values
			formData.add(name, field.value)
		}
		
		return formData
	}
	
	; Given a potentially HTML-unsafe string, return an HTML safe string
	; https://stackoverflow.com/a/6234804
	EscapeHTML(unsafe)
	{
		unsafe := StrReplace(unsafe, "&", "&amp;")
		unsafe := StrReplace(unsafe, "<", "&lt;")
		unsafe := StrReplace(unsafe, ">", "&gt;")
		unsafe := StrReplace(unsafe, """", "&quot;")
		unsafe := StrReplace(unsafe, "''", "&#039;")
		return unsafe
	}
	
	; Wrapper for Format that applies EscapeHTML to each value before passing
	; them on. Useful for dynamic HTML generation.
	FormatHTML(formatStr, values*)
	{
		for i, value in values
			values[i] := this.EscapeHTML(value)
		return Format(formatStr, values*)
	}
	
	
	; --- Nested Classes ---
	
	; Proxies method calls to AHK function calls, binding a given value to the
	; first parameter of the target function.
	;
	; For internal use only.
	;
	; Parameters:
	;   parent - The value to bind
	;
	class Dispatch
	{
		__New(parent)
		{
			this.parent := parent
		}
		
		__Call(params*)
		{
			; Make sure the given name is a function
			if !(fn := Func(params[1]))
				throw Exception("Unknown function: " params[1])
			
			; Make sure enough parameters were given
			if (params.length() < fn.MinParams)
				throw Exception("Too few parameters given to " fn.Name ": " params.length())
			
			; Make sure too many parameters weren't given
			if (params.length() > fn.MaxParams && !fn.IsVariadic)
				throw Exception("Too many parameters given to " fn.Name ": " params.length())
			
			; Change first parameter from the function name to the neutron instance
			params[1] := this.parent
			
			; Call the function
			return fn.Call(params*)
		}
	}
	
	; Handles Web Browser events
	; https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa768283%28v%3dvs.85%29
	;
	; For internal use only
	;
	; Parameters:
	;   parent - An instance of the Neutron class
	;
	class WBEvents
	{
		__New(parent)
		{
			this.parent := parent
		}
		
		DocumentComplete(wb)
		{
			; Inject the AHK objects into the JS scope
			wb.document.parentWindow.neutron := this.parent
			wb.document.parentWindow.ahk := new this.parent.Dispatch(this.parent)
		}
	}
	
	; Enumerator class that enumerates the items of an HTMLCollection (or other
	; JavaScript array).
	;
	; Best accessed through the .Each() helper method.
	;
	; Parameters:
	;   htmlCollection - The HTMLCollection to be enumerated.
	;
	class Enumerable
	{
		i := 0
		
		__New(htmlCollection)
		{
			this.collection := htmlCollection
		}
		
		_NewEnum()
		{
			return this
		}
		
		Next(ByRef i, ByRef elem)
		{
			if (this.i >= this.collection.length)
				return False
			i := this.i
			elem := this.collection.item(this.i++)
			return True
		}
	}
	
	; A collection similar to an OrderedDict designed for holding form data.
	; This collection allows duplicate keys and enumerates key value pairs in
	; the order they were added.
	class FormData
	{
		names := []
		values := []
		
		; Add a field to the FormData structure.
		;
		; Parameters:
		;   name - The form field name associated with the value
		;   value - The value of the form field
		;
		; Returns: Nothing
		;
		Add(name, value)
		{
			this.names.Push(name)
			this.values.Push(value)
		}
		
		; Get an array of all values associated with a name.
		;
		; Parameters:
		;   name - The form field name associated with the values
		;
		; Returns: An array of values
		;
		; Example:
		;
		; fd := new NeutronWindow.FormData()
		; fd.Add("foods", "hamburgers")
		; fd.Add("foods", "hotdogs")
		; fd.Add("foods", "pizza")
		; fd.Add("colors", "red")
		; fd.Add("colors", "green")
		; fd.Add("colors", "blue")
		; for i, food in fd.All("foods")
		;     out .= i ": " food "`n"
		; MsgBox, %out%
		;
		All(name)
		{
			values := []
			for i, v in this.names
				if (v == name)
					values.Push(this.values[i])
			return values
		}
		
		; Meta-function to allow direct access of field values using either dot
		; or bracket notation. Can retrieve the nth item associated with a given
		; name by passing more than one value in when bracket notation.
		;
		; Example:
		;
		; fd := new NeutronWindow.FormData()
		; fd.Add("foods", "hamburgers")
		; fd.Add("foods", "hotdogs")
		; MsgBox, % fd.foods ; hamburgers
		; MsgBox, % fd["foods", 2] ; hotdogs
		;
		__Get(name, n := 1)
		{
			for i, v in this.names
				if (v == name && !--n)
					return this.values[i]
		}
		
		; Allow iteration in the order fields were added, instead of a normal
		; object's alphanumeric order of iteration.
		;
		; Example:
		;
		; fd := new NeutronWindow.FormData()
		; fd.Add("z", "3")
		; fd.Add("y", "2")
		; fd.Add("x", "1")
		; for name, field in fd
		;     out .= name ": " field ","
		; MsgBox, %out% ; z: 3, y: 2, x: 1
		;
		_NewEnum()
		{
			return {"i": 0, "base": this}
		}
		Next(ByRef name, ByRef value)
		{
			if (++this.i > this.names.length())
				return False
			name := this.names[this.i]
			value := this.values[this.i]
			return True
		}
	}
}

global html := "
(

)"
global css := "
(
.main {
  margin: 0;
  padding: 0;
}
iframe {
  width: 100%;
  height: 100%;
}

)"
global js := "
(


)"
; Generated by Coffee-AHK/0.0.38
global __ci_shell__ := Func("shell_118")
global $ := {}
$.abs := Func("shell_117")
$.add := Func("shell_116")
$.alert := Func("shell_115")
$.beep := Func("shell_113")
$.bind := Func("shell_112")
$.blockInput := Func("shell_111")
$.ceil := Func("shell_110")
$.chunk := Func("shell_109")
$.clearInterval := Func("shell_108")
$.clearTimeout := Func("shell_107")
$.click := Func("shell_106")
$.clone := Func("shell_105")
$.compact := Func("shell_104")
$.concat := Func("shell_102")
global __iDebounce__ := 0
global __tDebounce__ := {}
$.debounce := Func("shell_101")
$.defer := Func("shell_99")
$.delay := Func("shell_97")
$.drop := Func("shell_95")
$.each := Func("shell_93")
class EmitterShellX {
  bus := []
  emit := Func("shell_92").Bind(this)
  off := Func("shell_91").Bind(this)
  on := Func("shell_90").Bind(this)
}
$.emitter := Func("shell_89")
global __eq__ := Func("shell_88")
$.eq := __eq__
$.exit := Func("shell_87")
class FileShellX {
  name := ""
  __New(name) {
    this.name := name
  }
  append := Func("shell_86").Bind(this)
  exist := Func("shell_85").Bind(this)
  delete := Func("shell_84").Bind(this)
  load := Func("shell_83").Bind(this)
  save := Func("shell_82").Bind(this)
}
$.file := Func("shell_81")
$.filter := Func("shell_80")
$.findColor := Func("shell_79")
$.findImage := Func("shell_78")
$.first := Func("shell_77")
$.head := $.first
$.floor := Func("shell_76")
$.formatHotkey := Func("shell_75")
global __formatKeyFormatHotkey__ := Func("shell_74")
global __pickPrefixFormatHotkey__ := Func("shell_73")
$.getColor := Func("shell_72")
$.getPosition := Func("shell_71")
$.getState := Func("shell_70")
$.gt := Func("shell_69")
$.gte := Func("shell_68")
$.i := Func("shell_67")
$.includes := Func("shell_66")
$.info := Func("shell_65")
$.isArray := Func("shell_64")
$.isFunction := Func("shell_63")
$.isNumber := Func("shell_62")
$.isObject := Func("shell_61")
$.isString := Func("shell_60")
$.join := Func("shell_59")
class KeyBindingShellX {
  mapBound := {}
  mapCallback := {}
  add := Func("shell_58").Bind(this)
  fire := Func("shell_57").Bind(this)
  init := Func("shell_56").Bind(this)
  off := Func("shell_54").Bind(this)
  on := Func("shell_53").Bind(this)
  remove := Func("shell_52").Bind(this)
}
global keyBindingShell := new KeyBindingShellX()
$.off := keyBindingShell.remove
$.on := keyBindingShell.add
$.trigger := keyBindingShell.fire
$.keys := Func("shell_51")
$.last := Func("shell_50")
$.length := Func("shell_49")
$.lt := Func("shell_48")
$.lte := Func("shell_47")
$.map := Func("shell_46")
$.mixin := Func("shell_45")
$.mod := Func("shell_44")
$.move := Func("shell_43")
$.noop := Func("shell_42")
$.now := Func("shell_41")
$.nth := Func("shell_40")
global __cacheOnce__ := {}
global __indexOnce__ := 0
$.once := Func("shell_39")
$.open := Func("shell_37")
$.play := Func("shell_36")
$.press := Func("shell_35")
global __formatInputPress__ := Func("shell_34")
global __validateInputPress__ := Func("shell_33")
$.push := Func("shell_32")
$.random := Func("shell_31")
$.range := Func("shell_30")
$.reload := Func("shell_29")
$.replace := Func("shell_28")
$.reverse := Func("shell_27")
$.round := Func("shell_26")
$.setFixed := Func("shell_25")
$.setInterval := Func("shell_24")
$.setTimeout := Func("shell_23")
$.shuffle := Func("shell_22").Bind(__split__)
$.sleep := Func("shell_21")
$.slice := Func("shell_20")
global __pickArgumentSlice__ := Func("shell_19")
$.sort := Func("shell_18")
$.split := Func("shell_17")
$.sum := Func("shell_16")
$.suspend := Func("shell_15")
$.tail := Func("shell_14")
$.take := Func("shell_13")
global __iThrottle__ := 0
global __tThrottle__ := {}
global __tsThrottle__ := {}
$.throttle := Func("shell_12")
$.toLowerCase := Func("shell_9")
$.toLower := $.toLowerCase
$.toString := Func("shell_8")
$.toUpperCase := Func("shell_7")
$.toUpper := $.toUpperCase
$.trim := Func("shell_6")
$.trimEnd := Func("shell_5")
$.trimStart := Func("shell_4")
$.type := Func("shell_3")
$.uniq := Func("shell_2")
$.values := Func("shell_1")
$.VERSION := "0.0.13"
shell_1(input) {
  __listResult__ := []
  for __index_for__, __key__ in $.keys.Call(input) {
    $.push.Call(__listResult__, input[__ci_shell__.Call(__key__)])
  }
  return __listResult__
}
shell_2(list) {
  __hasString__ := false
  for __index_for__, __item__ in list {
    if (($.type.Call(__item__)) == "string") {
      __hasString__ := true
      break
    }
  }
  __string__ := $.join.Call(list, ",")
  if (__hasString__) {
    Sort, __string__, C U D,
  } else {
    Sort, __string__, N U D,
  }
  return $.split.Call(__string__, ",")
}
shell_3(input) {
  if input is Number
    return "number"
  if (IsFunc(input)) {
    return "function"
  }
  if (IsObject(input)) {
    if (input.Count() == input.Length()) {
      if !(input.Length() >= 0) {
        return "function"
      }
      return "array"
    }
    return "object"
  }
  return "string"
}
shell_4(input, omitting := " `t") {
  return LTrim(input, omitting)
}
shell_5(input, omitting := " `t") {
  return RTrim(input, omitting)
}
shell_6(input, omitting := " `t") {
  return Trim(input, omitting)
}
shell_7(input) {
  StringUpper, __result__, input
  return __result__
}
shell_8(input) {
  __type__ := $.type.Call(input)
  if (__type__ == "array") {
    __result__ := ""
    for __index_for__, key in input {
      __result__ := "" . (__result__) . ", " . ($.toString.Call(key)) . ""
    }
    return "[" . ($.trim.Call(__result__, " ,")) . "]"
  } else if (__type__ == "object") {
    __result__ := ""
    for key, value in input {
      __result__ := "" . (__result__) . ", " . (key) . ": " . ($.toString.Call(value)) . ""
    }
    return "{" . ($.trim.Call(__result__, " ,")) . "}"
  }
  return input
}
shell_9(input) {
  StringLower, __result__, input
  return __result__
}
shell_10(callback, index) {
  callback.Call()
  __tsThrottle__[__ci_shell__.Call(index)] := $.now.Call()
}
shell_11(callback, time, index) {
  $.clearTimeout.Call(__tThrottle__[__ci_shell__.Call(index)])
  __tThrottle__[__ci_shell__.Call(index)] := $.setTimeout.Call(Func("shell_10").Bind(callback, index), __tsThrottle__[__ci_shell__.Call(index)] - $.now.Call() + time)
}
shell_12(time, callback) {
  __iThrottle__++
  __tsThrottle__[__ci_shell__.Call(__iThrottle__)] := 0
  return Func("shell_11").Bind(callback, time, __iThrottle__)
}
shell_13(list, count := 1) {
  __len__ := $.length.Call(list)
  if !(__len__) {
    return []
  }
  if !(count >= 0) {
    return []
  }
  if (count >= __len__) {
    count := __len__
  }
  __listNew__ := []
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    if (__i__ >= count) {
      break
    }
    $.push.Call(__listNew__, __item__)
  }
  return __listNew__
}
shell_14(list) {
  return $.drop.Call(list, 1)
}
shell_15(isSuspended := "Toggle") {
  if (isSuspended != "Toggle") {
    if (isSuspended) {
      isSuspended := "On"
    } else {
      isSuspended := "Off"
    }
  }
  Suspend, % isSuspended
}
shell_16(list) {
  __result__ := 0
  for __index_for__, __n__ in list {
    __result__ := __result__ + __n__
  }
  return __result__
}
shell_17(input, delimiter) {
  return StrSplit(input, delimiter)
}
shell_18(list) {
  __hasString__ := false
  for __index_for__, __item__ in list {
    if (($.type.Call(__item__)) == "string") {
      __hasString__ := true
      break
    }
  }
  __string__ := $.join.Call(list, ",")
  if (__hasString__) {
    Sort, __string__, C D,
  } else {
    Sort, __string__, N D,
  }
  return $.split.Call(__string__, ",")
}
shell_19(args) {
  switch $.length.Call(args) {
    case 1: {
      __array__ := [args[1], 0, $.length.Call(args[1])]
      __list__ := __array__[1]
      __start__ := __array__[2]
      __end__ := __array__[3]
    }
    case 2: {
      __array__ := [args[1], args[2], $.length.Call(args[1])]
      __list__ := __array__[1]
      __start__ := __array__[2]
      __end__ := __array__[3]
    }
    case 3: {
      __array__ := args
      __list__ := __array__[1]
      __start__ := __array__[2]
      __end__ := __array__[3]
    }
  }
  return [__list__, __start__, __end__]
}
shell_20(args*) {
  __array__ := __pickArgumentSlice__.Call(args)
  __list__ := __array__[1]
  __start__ := __array__[2]
  __end__ := __array__[3]
  __len__ := $.length.Call(__list__)
  if (__start__ > __len__) {
    __start__ := __len__
  }
  if (__start__ < 0) {
    __start__ := __len__ + __start__
  }
  if (__end__ > __len__) {
    __end__ := __len__
  }
  if (__end__ < 0) {
    __end__ := __len__ + __end__
  }
  __isReverse__ := false
  if (__start__ > __end__) {
    __isReverse__ := true
    __array__ := [__end__, __start__]
    __start__ := __array__[1]
    __end__ := __array__[2]
  }
  __listNew__ := []
  __n__ := 0
  __max__ := __end__ - __start__
  while (__n__ < __max__) {
    $.push.Call(__listNew__, __list__[__ci_shell__.Call(__start__ + __n__)])
    __n__++
  }
  if (__isReverse__) {
    return $.reverse.Call(__listNew__)
  }
  return __listNew__
}
shell_21(time) {
  Sleep, % time
}
shell_22(__split__, list) {
  __string__ := $.join.Call(list, ",")
  Sort, __string__, Random D,
  return __split__.Call(__string__, ",")
}
shell_23(callback, time) {
  callback := $.bind.Call(callback)
  if !($.isNumber.Call(time)) {
    throw Exception("$.setTimeout: invalid type")
  }
  if (time <= 0) {
    time := 1
  }
  SetTimer, % callback, % 0 - time
  return callback
}
shell_24(callback, time) {
  callback := $.bind.Call(callback)
  if !(time > 0) {
    throw Exception("$.setInterval: invalid value")
  }
  SetTimer, % callback, % time
  return callback
}
shell_25(isFixed := "Toggle") {
  if (isFixed != "Toggle") {
    if (isFixed) {
      isFixed := "On"
    } else {
      isFixed := "Off"
    }
  }
  Winset AlwaysOnTop, % isFixed, A
}
shell_26(n) {
  return Round(n)
}
shell_27(list) {
  __len__ := $.length.Call(list)
  __listNew__ := []
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    __listNew__[__ci_shell__.Call(__len__ - 1 - __i__)] := __item__
  }
  for __i__, __item__ in __listNew__ {
    __i__ := __i__ - 1
    list[__ci_shell__.Call(__i__)] := __item__
  }
  return list
}
shell_28(input, searchment, replacement, limit := -1) {
  return StrReplace(input, searchment, replacement, limit)
}
shell_29() {
  Reload
}
shell_30(args*) {
  switch $.length.Call(args) {
    case 1: {
      __array__ := [0, args[1], 1]
      __start__ := __array__[1]
      __end__ := __array__[2]
      __step__ := __array__[3]
    }
    case 2: {
      __array__ := [args[1], args[2], 1]
      __start__ := __array__[1]
      __end__ := __array__[2]
      __step__ := __array__[3]
    }
    case 3: {
      __array__ := args
      __start__ := __array__[1]
      __end__ := __array__[2]
      __step__ := __array__[3]
    }
    default: {
      throw Exception("$.range: invalid arguments")
    }
  }
  if (__start__ == __end__) {
    return [__start__]
  }
  if (__start__ > __end__) {
    return []
  }
  __listResult__ := []
  __n__ := 0
  __max__ := __end__ - __start__
  while (__n__ < __max__) {
    $.push.Call(__listResult__, __start__ + __step__ * __n__)
    __n__++
  }
  return __listResult__
}
shell_31(min := 0, max := 1) {
  Random, __result__, min, max
  return __result__
}
shell_32(list, args*) {
  for __index_for__, __arg__ in args {
    list.Push(__arg__)
  }
  return list
}
shell_33(listInput) {
  if !($.length.Call(listInput)) {
    return false
  }
  __key__ := listInput[1]
  if ($.includes.Call(__key__, "-button")) {
    __key__ := $.replace.Call(__key__, "l-button", "left")
    __key__ := $.replace.Call(__key__, "m-button", "middle")
    __key__ := $.replace.Call(__key__, "r-button", "right")
    $.click.Call(__key__)
    return false
  }
  return true
}
shell_34(listInput) {
  __listKey__ := []
  for __index_for__, __input__ in listInput {
    __ipt__ := $.toLowerCase.Call(__input__)
    __ipt__ := $.replace.Call(__ipt__, " ", "")
    __ipt__ := $.replace.Call(__ipt__, "-", "")
    $.push.Call(__listKey__, ($.split.Call(__ipt__, "+"))*)
  }
  return __listKey__
}
shell_35(listInput*) {
  if !(__validateInputPress__.Call(listInput)) {
    return
  }
  __listKey__ := __formatInputPress__.Call(listInput)
  __listResult__ := []
  __len__ := $.length.Call(__listKey__)
  for __i__, __key__ in __listKey__ {
    __i__ := __i__ - 1
    if (__i__ == __len__ - 1) {
      __listResult__[__ci_shell__.Call(__i__)] := $.split.Call(__key__, ":")
      continue
    }
    if ($.includes.Call(__key__, ":")) {
      __listResult__[__ci_shell__.Call(__i__)] := $.split.Call(__key__, ":")
      __listResult__[__ci_shell__.Call((__len__ - 1) * 2 - __i__)] := $.split.Call(__key__, ":")
    } else {
      __listResult__[__ci_shell__.Call(__i__)] := [__key__, "down"]
      __listResult__[__ci_shell__.Call((__len__ - 1) * 2 - __i__)] := [__key__, "up"]
    }
  }
  for __i__, __it__ in __listResult__ {
    __i__ := __i__ - 1
    if (__it__[1] == "win") {
      __it__[1] := "lwin"
    }
    __listResult__[__ci_shell__.Call(__i__)] := $.trim.Call("" . (__it__[1]) . " " . (__it__[2]) . "")
  }
  __result__ := ""
  for __index_for__, __it__ in __listResult__ {
    __result__ := "" . (__result__) . "{" . (__it__) . "}"
  }
  Send, % __result__
}
shell_36(filename) {
  SoundPlay, % filename
}
shell_37(source) {
  Run, % source
}
shell_38(__i__, callback, args*) {
  if (__cacheOnce__[__ci_shell__.Call(__i__)][1]) {
    return __cacheOnce__[__ci_shell__.Call(__i__)][2]
  }
  __result__ := callback.Call(args*)
  __cacheOnce__[__ci_shell__.Call(__i__)] := [true, __result__]
  return __result__
}
shell_39(callback) {
  __i__ := __indexOnce__
  __indexOnce__++
  __cacheOnce__[__ci_shell__.Call(__i__)] := [false, ""]
  return Func("shell_38").Bind(__i__, callback)
}
shell_40(list, n := 0) {
  if (n >= 0) {
    return list[__ci_shell__.Call(n)]
  } else {
    return list[__ci_shell__.Call(($.length.Call(list)) + n)]
  }
}
shell_41() {
  return A_TickCount
}
shell_42() {
  return
}
shell_43(point := "", speed := 0) {
  MouseMove, point[1], point[2], speed
}
shell_44(dividend, divisor) {
  return Mod(dividend, divisor)
}
shell_45(args*) {
  if !($.length.Call(args)) {
    throw Exception("$.mixin: invalid arguments")
  }
  __result__ := args[1]
  for __index_for__, __item__ in $.tail.Call(args) {
    for __key__, __value__ in __item__ {
      __result__[__ci_shell__.Call(__key__)] := __value__
    }
  }
  return __result__
}
shell_46(list, callback) {
  __listResult__ := []
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    $.push.Call(__listResult__, callback.Call(__item__, __i__))
  }
  return __listResult__
}
shell_47(value, other) {
  return value <= other
}
shell_48(value, other) {
  return value < other
}
shell_49(input) {
  __type__ := $.type.Call(input)
  switch __type__ {
    case "array": {
      return input.Length()
    }
    case "object": {
      return input.Count()
    }
    case "string": {
      return StrLen(input)
    }
    default: {
      throw Exception("$.length: invalid type '" . (__type__) . "'")
    }
  }
}
shell_50(list) {
  return list[__ci_shell__.Call(($.length.Call(list)) - 1)]
}
shell_51(input) {
  __listResult__ := []
  for __key__, __value__ in input {
    $.push.Call(__listResult__, __key__)
  }
  return $.sort.Call(__listResult__)
}
shell_52(this, key) {
  __array__ := $.split.Call(key, ".")
  key := __array__[1]
  __name__ := __array__[2]
  if !(__name__) {
    this.mapCallback[__ci_shell__.Call(key)] := ""
    this.off.Call(key, this.mapBound[__ci_shell__.Call(key)])
    return $
  }
  __listNew__ := []
  for __index_for__, __item__ in this.mapCallback[__ci_shell__.Call(key)] {
    if (__item__[1] == __name__) {
      continue
    }
    $.push.Call(__listNew__, __item__)
  }
  if !($.length.Call(__listNew__)) {
    this.mapCallback[__ci_shell__.Call(key)] := ""
    this.off.Call(key, this.mapBound[__ci_shell__.Call(key)])
    return $
  }
  this.mapCallback[__ci_shell__.Call(key)] := __listNew__
  return $
}
shell_53(this, key, callback) {
  key := $.formatHotkey.Call($.replace.Call(key, ":down", ""))
  Hotkey, % key, % callback, On
  return $
}
shell_54(this, key, callback) {
  key := $.formatHotkey.Call($.replace.Call(key, ":down", ""))
  Hotkey, % key, % callback, Off
  return $
}
shell_55(key, this) {
  this.fire.Call(key)
}
shell_56(this, key) {
  if (this.mapCallback[__ci_shell__.Call(key)]) {
    return $
  }
  this.mapCallback[__ci_shell__.Call(key)] := []
  __fn__ := Func("shell_55").Bind(key, this)
  this.mapBound[__ci_shell__.Call(key)] := __fn__
  this.on.Call(key, __fn__)
}
shell_57(this, key) {
  __array__ := $.split.Call(($.replace.Call(key, ":down", "")), ".")
  key := __array__[1]
  __name__ := __array__[2]
  if !(__name__) {
    for __index_for__, __item__ in this.mapCallback[__ci_shell__.Call(key)] {
      __item__[2].Call()
    }
    return $
  }
  for __index_for__, __item__ in this.mapCallback[__ci_shell__.Call(key)] {
    if !(__item__[1] == __name__) {
      continue
    }
    __item__[2].Call()
  }
  return $
}
shell_58(this, key, callback) {
  __array__ := $.split.Call(key, ".")
  key := __array__[1]
  __name__ := __array__[2]
  this.init.Call(key)
  $.push.Call(this.mapCallback[__ci_shell__.Call(key)], [__name__, callback])
  return $
}
shell_59(list, seperator := ",") {
  __result__ := ""
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    if !(__i__) {
      __result__ := __item__
      continue
    }
    __result__ := "" . (__result__) . "" . (seperator) . "" . (__item__) . ""
  }
  return __result__
}
shell_60(input) {
  __type__ := $.type.Call(input)
  if !(__type__ == "string") {
    return false
  }
  return true
}
shell_61(input) {
  __type__ := $.type.Call(input)
  if !(__type__ == "object") {
    return false
  }
  return true
}
shell_62(input) {
  __type__ := $.type.Call(input)
  if !(__type__ == "number") {
    return false
  }
  return true
}
shell_63(input) {
  __type__ := $.type.Call(input)
  if !(__type__ == "function") {
    return false
  }
  return true
}
shell_64(input) {
  __type__ := $.type.Call(input)
  if !(__type__ == "array") {
    return false
  }
  return true
}
shell_65(message, point := "") {
  if !(message) {
    return message
  }
  if !(point) {
    point := $.getPosition.Call()
  }
  __msg__ := $.toString.Call(message)
  ToolTip, % __msg__, % point[1], % point[2]
  return message
}
shell_66(input, needle) {
  __type__ := $.type.Call(input)
  if (__type__ == "string" || __type__ == "number") {
    return (InStr(input, needle)) > 0
  }
  if (__type__ == "array") {
    for __index_for__, __it__ in input {
      if (__it__ == needle) {
        return true
      }
    }
    return false
  }
  throw Exception("$.includes: invalid type '" . (__type__) . "'")
}
shell_67(message) {
  $.info.Call("[" . ($.now.Call()) . "] " . ($.toString.Call(message)) . "", [0, 0])
  return message
}
shell_68(value, other) {
  return value >= other
}
shell_69(value, other) {
  return value > other
}
shell_70(key) {
  key := $.formatHotkey.Call(key)
  return GetKeyState(key, "P")
}
shell_71() {
  MouseGetPos, __x__, __y__
  return [__x__, __y__]
}
shell_72(point := "") {
  if !(point) {
    point := $.getPosition.Call()
  }
  PixelGetColor, __result__, % point[1], % point[2], RGB
  return __result__
}
shell_73(listKey) {
  if (($.length.Call(listKey)) == 1) {
    return ["", listKey]
  }
  __prefix__ := ""
  __listNew__ := []
  for __index_for__, __key__ in listKey {
    if (__key__ == "alt") {
      __prefix__ := "" . (__prefix__) . "!"
      continue
    }
    if (__key__ == "ctrl") {
      __prefix__ := "" . (__prefix__) . "^"
      continue
    }
    if (__key__ == "shift") {
      __prefix__ := "" . (__prefix__) . "+"
      continue
    }
    if (__key__ == "win") {
      __prefix__ := "" . (__prefix__) . "#"
      continue
    }
    $.push.Call(__listNew__, __key__)
  }
  return [__prefix__, __listNew__]
}
shell_74(key) {
  __listKey__ := []
  __key__ := $.toLowerCase.Call(key)
  __key__ := $.replace.Call(__key__, " ", "")
  __key__ := $.replace.Call(__key__, "-", "")
  $.push.Call(__listKey__, ($.split.Call(__key__, "+"))*)
  return __listKey__
}
shell_75(key) {
  __listKey__ := __formatKeyFormatHotkey__.Call(key)
  __array__ := __pickPrefixFormatHotkey__.Call(__listKey__)
  __prefix__ := __array__[1]
  __listKey__ := __array__[2]
  __result__ := ""
  for __index_for__, __it__ in __listKey__ {
    __result__ := "" . (__result__) . " & " . (__it__) . ""
  }
  return $.replace.Call("" . (__prefix__) . "" . ($.trim.Call(__result__, " &")) . "", ":", " ")
}
shell_76(n) {
  return Floor(n)
}
shell_77(list) {
  return list[1]
}
shell_78(source, start := "", end := "") {
  if !(start) {
    start := [0, 0]
  }
  if !(end) {
    end := [A_ScreenWidth, A_ScreenHeight]
  }
  ImageSearch __x__, __y__, start[1], start[2], end[1], end[2], % A_ScriptDir . "\\\" . source
  return [__x__, __y__]
}
shell_79(color, start := "", end := "", variation := 0) {
  if !(start) {
    start := [0, 0]
  }
  if !(end) {
    end := [A_ScreenWidth, A_ScreenHeight]
  }
  PixelSearch __x__, __y__, start[1], start[2], end[1], end[2], color, variation, Fast RGB
  return [__x__, __y__]
}
shell_80(list, callback) {
  __listResult__ := []
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    if !(callback.Call(__item__, __i__)) {
      continue
    }
    $.push.Call(__listResult__, __item__)
  }
  return __listResult__
}
shell_81(name) {
  return new FileShellX(name)
}
shell_82(this, content) {
  this.delete.Call()
  return this.append.Call(content)
}
shell_83(this) {
  if !(this.exist.Call()) {
    return ""
  }
  FileRead, __result__, % this.name
  return $.replace.Call(__result__, "`r", "")
}
shell_84(this) {
  if !(this.exist.Call()) {
    return this
  }
  FileDelete, % this.name
  return this
}
shell_85(this) {
  if !(FileExist(this.name)) {
    return false
  }
  return true
}
shell_86(this, content) {
  FileAppend, % content, % this.name, UTF-8
  return content
}
shell_87() {
  ExitApp
}
shell_88(value, other) {
  __typeA__ := $.type.Call(value)
  __typeB__ := $.type.Call(other)
  if !(__typeA__ == __typeB__) {
    return false
  }
  if ($.includes.Call(["function", "number", "string"], __typeA__)) {
    return value == other
  }
  __lengthA__ := $.length.Call(value)
  __lengthB__ := $.length.Call(other)
  if !(__lengthA__ == __lengthB__) {
    return false
  }
  if (__typeA__ == "array") {
    for __i__, __it__ in value {
      __i__ := __i__ - 1
      if !(__eq__.Call(__it__, other[__ci_shell__.Call(__i__)])) {
        return false
      }
    }
    return true
  }
  for __k__, __v__ in value {
    if !(__eq__.Call(__v__, other[__ci_shell__.Call(__k__)])) {
      return false
    }
  }
  return true
}
shell_89() {
  return new EmitterShellX
}
shell_90(this, key, callback) {
  __array__ := $.split.Call(key, ".")
  __type__ := __array__[1]
  __name__ := __array__[2]
  $.push.Call(this.bus, [__type__, __name__, callback])
  return this
}
shell_91(this, key) {
  __array__ := $.split.Call(key, ".")
  __type__ := __array__[1]
  __name__ := __array__[2]
  if !(__type__) {
    this.bus := []
    return this
  }
  if !(__name__) {
    __busNew__ := []
    for __index_for__, __item__ in this.bus {
      if (__item__[1] == __type__) {
        continue
      }
      $.push.Call(__busNew__, __item__)
    }
    this.bus := __busNew__
    return this
  }
  __busNew__ := []
  for __index_for__, __item__ in this.bus {
    if (__item__[1] == __type__ && __item__[2] == __name__) {
      continue
    }
    $.push.Call(__busNew__, __item__)
  }
  this.bus := __busNew__
  return this
}
shell_92(this, key, args*) {
  __array__ := $.split.Call(key, ".")
  __type__ := __array__[1]
  __name__ := __array__[2]
  if !(__type__) {
    return this
  }
  if !(__name__) {
    for __index_for__, __item__ in this.bus {
      if !(__item__[1] == __type__) {
        continue
      }
      __item__[3].Call(args*)
    }
    return this
  }
  for __index_for__, __item__ in this.bus {
    if !(__item__[1] == __type__ && __item__[2] == __name__) {
      continue
    }
    __item__[3].Call(args*)
  }
  return this
}
shell_93(list, callback) {
  for __i__, __item__ in list {
    __i__ := __i__ - 1
    callback.Call(__item__, __i__)
  }
}
shell_94(n, _it, i) {
  return i >= n
}
shell_95(list, n := 1) {
  return $.filter.Call(list, Func("shell_94").Bind(n))
}
shell_96(callback, args) {
  callback.Call(args*)
}
shell_97(callback, time, args*) {
  __timer__ := $.setTimeout.Call(Func("shell_96").Bind(callback, args), time)
  return __timer__
}
shell_98(callback, args) {
  callback.Call(args*)
}
shell_99(callback, args*) {
  return $.delay.Call(Func("shell_98").Bind(callback, args), 1)
}
shell_100(callback, time, index) {
  $.clearTimeout.Call(__tDebounce__[__ci_shell__.Call(index)])
  __tDebounce__[__ci_shell__.Call(index)] := $.setTimeout.Call(callback, time)
}
shell_101(time, callback) {
  __iDebounce__++
  return Func("shell_100").Bind(callback, time, __iDebounce__)
}
shell_102(list, args*) {
  __listNew__ := $.clone.Call(list)
  for __index_for__, __arg__ in args {
    __type__ := $.type.Call(__arg__)
    if (__type__ == "array") {
      for __index_for__, __item__ in __arg__ {
        $.push.Call(__listNew__, __item__)
      }
    } else {
      $.push.Call(__listNew__, __arg__)
    }
  }
  return __listNew__
}
shell_103(it) {
  return it
}
shell_104(list) {
  return $.filter.Call(list, Func("shell_103"))
}
shell_105(input) {
  __type__ := $.type.Call(input)
  if (__type__ == "array") {
    return $.slice.Call(input)
  }
  if (__type__ == "object") {
    __mapNew__ := {}
    for __key__, __value__ in input {
      __mapNew__[__ci_shell__.Call(__key__)] := __value__
    }
    return __mapNew__
  }
  throw Exception("$.clone: invalid type '" . (__type__) . "'")
}
shell_106(key := "left") {
  key := $.replace.Call(key, "-", "")
  key := $.replace.Call(key, ":", " ")
  Click, % key
}
shell_107(callback) {
  if !(callback) {
    return
  }
  SetTimer, % callback, Delete
}
shell_108(callback) {
  if !(callback) {
    return
  }
  SetTimer, % callback, Delete
}
shell_109(list, n := 1) {
  __listNew__ := []
  __length__ := $.length.Call(list)
  __i__ := 0
  while (__i__ < __length__ / n) {
    __listTemp__ := []
    __j__ := 0
    while (__j__ < n) {
      __index__ := __i__ * n + __j__
      if !(__index__ < __length__) {
        break
      }
      $.push.Call(__listTemp__, list[__ci_shell__.Call(__index__)])
      __j__++
    }
    $.push.Call(__listNew__, __listTemp__)
    __i__++
  }
  return __listNew__
}
shell_110(n) {
  return Ceil(n)
}
shell_111(block) {
  if (block) {
    BlockInput, On
    return
  }
  BlockInput, Off
}
shell_112(callback, args*) {
  if !(callback.Name) {
    if !($.length.Call(args)) {
      return callback
    }
    throw Exception("$.bind: cannot bind a bound function")
  }
  return callback.Bind(args*)
}
shell_113() {
  SoundBeep
}
shell_114(msg) {
  return $.toString.Call(msg)
}
shell_115(message*) {
  __msg__ := $.join.Call(($.map.Call(message, Func("shell_114"))), ", ")
  MsgBox, % __msg__
}
shell_116(args*) {
  __result__ := 0
  for __index_for__, __arg__ in args {
    __result__ := __result__ + __arg__
  }
  return __result__
}
shell_117(n) {
  return Abs(n)
}
shell_118(input) {
  if input is Number
    return input + 1
  return input
}

global title := "Homepage"
global width := 1280
global height := 720
global webview := new NeutronWindow(html, css, js, title)
webview.Gui("+LabelNeutron")
webView.Show("w" . (width) . " h" . (height) . "")
webView.Load("build/index.html")
return

NeutronClose:
ExitApp
return

